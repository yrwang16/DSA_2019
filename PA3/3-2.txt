庐州月：
1. 本题使用贪心+平衡二叉树来解决，具体选择为AVL树。
2. 本题解决思路如下：首先将桥和材料都按美观度排序，本题选用快排，时间复杂度为O（nlogn）和O（mlogm）。
3. 接下来优先修美观度要求最高的桥，对每座桥选择美观符合的情况下造价最低的材料（贪心）。
4. 修的具体过程：使用AVL树来存储材料节点（按价格排序），首先在剩余未被选择的材料里面，找到所有美观大于等于当前桥需求的材料。
5. 在边遍历美观符合要求的材料的过程中，边将其插进AVL树中。
6. 插入后，树中即为所有美观符合条件的点（包括修完上座桥剩下的树和新加进去的节点），search（当前桥cost需求）。
7. search返回值为不小于cost的最小值，将其remove即可。
8. 具体难点为search的过程：查找cost有两种情况：
	A.未命中，B恰好命中，此时需要巧妙设计search算法：
	采用递归查找的方式，比当前节点小，转入左子树查找，若比当前节点key大，转入右子树
	若直接命中查找key值/命中空节点，则返回对应key值/NULL
	在接受到返回值之后，search函数会分两种情况在处理
		当从左子树返回时，判断是否为NULL，
			若为NULL且当前节点比查找key大，则返回当前节点key
			若不比查找结点大，继续放回NULL。
			若返回非NULL（说明命中或找到不小于cost的最小节点），如实返回即可。
		当从右子树返回时，无论返回值为何，均不做处理，
			因为向下递归查找的时候就是因为当前节点key小于cost才分给右子树查找的，
			不可能符合（比cost大的最小key）这一条件，如实返回即可，
			命中最好，不命中（NULL）也有上面的足够大的节点来处理（左子树返回）
	经过由此设计的算法，在tree里有cost的时候可命中，在没有的时候返回不小于cost的最小key。
9. 采用在Node里加一个num计数变量的方式来处理重复数据，具体即为：
		insert时，若直接命中该节点，num自增，若没有该key，则正常创建节点插进avl树。
		remove时，本质上就是search算法（因为放回的时命中节点的指针，search后可直接处理），此时额外判断一下num>1？
		大于1说明不止有一份，num--即可，若num==1，则直接删掉该节点。
10. 复杂度分析，因为本题n，m同阶，因此：
		预处理的排序过程O（nlogn+mlogm）=O（nlogn）
		外层遍历n（桥）的过程中，每一步执行AVLtree的插入，查询，删除操作，其中查询和删除均为O（logm），n次为O（nlogm）
		虽然每次插入的数量不确定，但插入的总和确实确定的，即为最多m个节点，时间成本不超过O（mlogm）
		因此，时间成本为O（nlogn）（因为n，m同阶），空间成本O（n).